stream type ThreadEvent shared(timestamp: uint64_t)
{
    read(addr : uintptr_t);
    write(addr : uintptr_t);
    atomicread(addr : uintptr_t, mode : int);
    atomicwrite(addr : uintptr_t, mode : int);
    lock(addr : uintptr_t);
    unlock(addr : uintptr_t);
    alloc(addr : uintptr_t, size : size_t);
    free(addr : uintptr_t);
    fork(newthreadid: uint64_t) creates ThreadEvent;
    join(threadid: uint64_t);
    write_n(addr : uintptr_t, size: size_t);
    read_n(addr : uintptr_t, size: size_t);
}
stream type ThreadEventH(threadid: int, inhole : int16_t, nextts: uint64_t, loststart: uint64_t, lastlost : uint64_t) extends ThreadEvent aggregate (uint64_t maxts = MAX(shared timestamp))
{
    my_hole(n : uint64_t, lastts: uint64_t);
}
stream processor TEProcessor(threadid : int) : ThreadEvent() -> ThreadEventH(threadid, 0, 0, 0, 0) to autodrop(@BUFSIZE,256)
{
    on fork(ts, ntid) creates ThreadEvent process using TEProcessor(ntid) include in Threads forward;
    hole my_hole
    {
        uint64_t timestamp = MIN(shared timestamp);
        uint64_t n = COUNT(*);
        uint64_t lastts = MAX(shared timestamp);
    }
}

buffer group Threads : ThreadEventH order by shared timestamp assume MAX(maxts) m0m 100
event source Program : ThreadEvent process using TEProcessor(0)  include in Threads

stream type GlobalEvent shared (tid: int, timestamp: uint64_t)
{
    read(addr : uintptr_t);
    write(addr : uintptr_t);
    read_sized(addr : uintptr_t, size: size_t);
    write_sized(addr : uintptr_t, size: size_t);
    lock(addr : uintptr_t);
    unlock(addr : uintptr_t);
    fork(newthreadid: int);
    join(threadid: int);
    skipstart();
    skipend();
    done_();
}
globals
$$
    //#define DEBUGPRINT

    #include <limits.h>
    #include <stdint.h>
    #include <inttypes.h>
    #include "monitor.h"
    uint64_t minholeend=UINT64_MAX;
    uint64_t lastemitts=0;
    uint64_t skipcount=0;
    uint64_t dropcount=0;
    uint64_t holescount=0;
    uint64_t monitorcount=0;
    #define min(a, b) __vamos_min(a, b)
    #define max(a, b) __vamos_max(a, b)
$$

cleanup
$$
    fprintf(stderr, "Processed %lu events in monitor\n", monitorcount);
    fprintf(stderr, "Dropped %lu events in %lu holes\n", dropcount, holescount);
    fprintf(stderr, "Found %lu races\n", GetRaceCount());
$$

loopdebug
$$
    printf("skipcount = %lu\n", skipcount);
    printf("dropcount = %lu\n", dropcount);
    printf("holescount = %lu\n", holescount);
$$

arbiter : GlobalEvent
{
    rule set main
    {
        choose first all T from Threads
        {
            on T : done
            $$
                #ifdef DEBUGPRINT
                printf("done(tid=%i)\n", $T.threadid;);
                #endif
                $yield done_($T.threadid;, lastemitts);
                $remove T from Threads;
            $$
        }
        choose first T from Threads
        {
            on T : nothing
            $$
                //ignore - threads without events still too far up front in order
            $$
            on T : shared(ts) | where $$ ts < lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("lost(tid=%i, ts=%lu, lastemitts=%lu)\n", $T.threadid;, ts, lastemitts);
                #endif
                if($T.loststart; == 0)
                {
                    $T.loststart; = ts;
                }
                $T.lastlost; = ts;
            $$
            on T : | shared(ts) where $$ $T.loststart; > 0$$
            $$
                #ifdef DEBUGPRINT
                printf("skip(tid=%i, from=%lu, to=%lu, current=%lu, lastemitts=%lu)\n", $T.threadid;, $T.loststart;, $T.lastlost;, ts, lastemitts);
                #endif
                $yield skipstart($T.threadid;, lastemitts);
                $yield skipend($T.threadid;, ts);
                lastemitts=ts;
                $T.loststart; = 0;
            $$
            on T : | shared(ts) where $$ ts >= minholeend $$
            $$
                $switch to processhole;
            $$
            on T : my_hole(ts, n , lastts) |
            $$
                #ifdef DEBUGPRINT
                printf("hole(tid=%i, first=%lu, n=%lu, last=%lu)\n", $T.threadid;, ts, n, lastts);
                #endif
                skipcount+=n;
                dropcount+=n;
                holescount+=1;
                $yield skipstart($T.threadid;, ts);
                lastemitts=ts;
                if(lastts < minholeend)
                {
                    minholeend = lastts;
                }
                $T.nextts; = lastts;
                $T.inhole; = 1;
            $$
            on T : read(ts, addr) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("read(tid=%i, ts=%lu, addr=%p)\n", $T.threadid;, ts, (void*)addr);
                #endif
                $yield read($T.threadid;, ts, addr);
                lastemitts=ts;
            $$
            on T : write(ts,addr) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("write(tid=%i, ts=%lu, addr=%p)\n", $T.threadid;, ts, (void*)addr);
                #endif
                $yield write($T.threadid;, ts, addr);
                lastemitts=ts;
            $$
            on T : read_n(ts,addr, size) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("read_n(tid=%i, ts=%lu, addr=%p, size=%lu)\n", $T.threadid;, ts, (void*)addr, size);
                #endif
                $yield read_sized($T.threadid;, ts, addr, size);
                lastemitts=ts;
            $$
            on T : write_n(ts,addr,size) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("write_n(tid=%i, ts=%lu, addr=%p. size=%lu)\n", $T.threadid;, ts, (void*)addr, size);
                #endif
                $yield write_sized($T.threadid;, ts, addr, size);
                lastemitts=ts;
            $$

            on T : lock(ts,addr) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("lock(tid=%i, ts=%lu, addr=%p)\n", $T.threadid;, ts, (void*)addr);
                #endif
                $yield lock($T.threadid;, ts, addr);
                lastemitts=ts;
            $$
            on T : unlock(ts,addr) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("unlock(tid=%i, ts=%lu, addr=%p)\n", $T.threadid;, ts, (void*)addr);
                #endif
                $yield unlock($T.threadid;, ts, addr);
                lastemitts=ts;
            $$ 
            on T : fork(ts,tid) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("fork(tid=%i, ts=%lu, otid=%i)\n", $T.threadid;, ts, (int) tid);
                #endif
                $yield fork($T.threadid;, ts, tid);
                lastemitts=ts;
            $$
            on T : join(ts,tid) | where $$ ts >= lastemitts $$
            $$
                #ifdef DEBUGPRINT
                printf("join(tid=%i, ts=%lu, otid=%i)\n", $T.threadid;, ts, (int) tid);
                #endif
                $yield join($T.threadid;, ts, tid);
                lastemitts=ts;
            $$
        }
    }
    rule set processhole
    {
        choose first all T from Threads
        {
            on T : 0 where $$ $T.inhole; && $T.nextts; == minholeend $$
            $$
                $yield skipend($T.threadid;, $T.nextts;);
                if($T.nextts;<lastemitts)
                {
                    printf("ERROR: skipped hole end!\n");
                    exit(0);
                }
                lastemitts=$T.nextts;;
                $T.inhole; = 0;
                minholeend=UINT64_MAX;
                $switch to findnexthole;
            $$
        }
        always
        $$
            minholeend=UINT64_MAX;
            $switch to findnexthole;
        $$
    }
    rule set findnexthole
    {
        choose first all T from Threads
        {
            on T : 0 where $$ $T.inhole; && $T.nextts; < minholeend $$
            $$
                minholeend = $T.nextts;;
            $$
        }
        always
        $$
            $switch to main;
        $$
    }
}

monitor {
    on read(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": read from %" PRIXPTR " @ %i\n", timestamp, addr, tid);
        #endif
        monitor_handle_read(tid, timestamp, addr);
        monitorcount++;
    $$
    on read_sized(tid, timestamp, addr, size) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": read_sized from %" PRIXPTR " @ %i\n", timestamp, addr, tid);
        #endif
        monitor_handle_read_many(tid, timestamp, addr, size);
        monitorcount++;
    $$

    on write(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": write to %" PRIXPTR " @ %i\n", timestamp, addr, tid);
        #endif
        monitor_handle_write(tid, timestamp, addr);
        monitorcount++;
    $$
    on write_sized(tid, timestamp, addr, size) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": write_sized to %" PRIXPTR " @ %i\n", timestamp, addr, tid);
        #endif
        monitor_handle_write_many(tid, timestamp, addr, size);
        monitorcount++;
    $$

    on lock(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": lock %" PRIXPTR " @ %i\n", timestamp, addr, tid);
        #endif
        monitor_handle_lock(tid, timestamp, addr);
        monitorcount++;
    $$

    on unlock(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": unlock %" PRIXPTR " @ %i\n", timestamp, addr, tid);
        #endif
        monitor_handle_unlock(tid, timestamp, addr);
        monitorcount++;
    $$

    on fork(tid, timestamp, newthreadid) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": fork %i @ %i\n", timestamp, newthreadid, tid);
        #endif
        monitor_handle_fork(tid, timestamp, newthreadid);
        monitorcount++;
    $$
    on join(tid, timestamp, threadid) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": join %i @ %i\n", timestamp, threadid, tid);
        #endif
        monitor_handle_join(tid, timestamp, threadid);
        monitorcount++;
    $$
    on skipstart(tid, timestamp) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": skipstart @ %i\n", timestamp, tid);
        #endif
        monitor_handle_skip_start(tid, timestamp);
        monitorcount++;
    $$
    on skipend(tid, timestamp) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": skipend @ %i\n", timestamp, tid);
        #endif
        monitor_handle_skip_end(tid, timestamp);
        monitorcount++;
    $$
    on done_(tid, timestamp) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("M%" PRIu64 ": done @ %i\n", timestamp, tid);
        #endif
        monitor_handle_done(tid, timestamp);
        monitorcount++;
    $$

}
