stream type ThreadEvent(threadid: int, inhole : int, nonecount : uint64_t, curts: uint64_t, nonets: uint64_t, skipping : int)
{
    read(timestamp: uint64_t, addr : intptr_t);
    write(timestamp: uint64_t, addr : intptr_t);
    atomicread(timestamp: uint64_t, addr : intptr_t, mode : int);
    atomicwrite(timestamp: uint64_t, addr : intptr_t, mode : int);
    lock(timestamp: uint64_t, addr : intptr_t);
    unlock(timestamp: uint64_t, addr : intptr_t);
    alloc(timestamp : uint64_t, addr : intptr_t, size : size_t);
    free(timestamp: uint64_t, addr : intptr_t);
    fork(timestamp: uint64_t, newthreadid: uint64_t) creates ThreadEvent;
    join(timestamp: uint64_t, threadid: uint64_t);
    write_n(timestamp: uint64_t, addr : intptr_t, size: size_t);
    read_n(timestamp: uint64_t, addr : intptr_t, size: size_t);
}
stream processor TEProcessor(threadid : int) : ThreadEvent(threadid, 0, 0, 0, 0, 0) -> ThreadEvent(threadid, 0, 0, 0, 0, 0) extends FORWARD
{
    on fork(ts, ntid) creates ThreadEvent process using TEProcessor(ntid) to autodrop(@BUFSIZE,256) include in Threads forward;
    my_hole
    {
        int n = COUNT(*);
        uint64_t firstts = MIN(read.timestamp, write.timestamp, atomicread.timestamp, atomicwrite.timestamp, lock.timestamp, unlock.timestamp, alloc.timestamp, free.timestamp, fork.timestamp, join.timestamp);
        uint64_t lastts = MAX(read.timestamp, write.timestamp, atomicread.timestamp, atomicwrite.timestamp, lock.timestamp, unlock.timestamp, alloc.timestamp, free.timestamp, fork.timestamp, join.timestamp);
    }
}

buffer group Threads : ThreadEvent order by round robin
event source Program : ThreadEvent process using TEProcessor(0) to autodrop(@BUFSIZE,256) include in Threads

stream type GlobalEvent
{
    read(tid: int, timestamp: uint64_t, addr : intptr_t);
    write(tid: int, timestamp: uint64_t, addr : intptr_t);
    read_sized(tid: int, timestamp: uint64_t, addr : intptr_t, size: size_t);
    write_sized(tid: int, timestamp: uint64_t, addr : intptr_t, size: size_t);
    atomicread(tid: int, timestamp: uint64_t, addr : intptr_t, mode : int);
    atomicwrite(tid: int, timestamp: uint64_t, addr : intptr_t, mode : int);
    lock(tid: int, timestamp: uint64_t, addr : intptr_t);
    unlock(tid: int, timestamp: uint64_t, addr : intptr_t);
    alloc(tid: int, timestamp : uint64_t, addr : intptr_t, size : size_t);
    free(tid: int, timestamp: uint64_t, addr : intptr_t);
    fork(tid: int, timestamp: uint64_t, newthreadid: int);
    join(tid: int, timestamp: uint64_t, threadid: int);
    skipstart(tid: int, timestamp : uint64_t);
    skipend(tid: int, timestamp : uint64_t);
    done_(tid: int, timestamp : uint64_t);
}
globals
$$
    #include <limits.h>
    #include "monitor.h"
    uint64_t nextts=1;
    uint64_t leastts=ULLONG_MAX;
    uint64_t nonebarrier=1;
    uint64_t nonecycles=0;
    uint64_t dropcount=0;
    uint64_t holescount=0;
    int seenNone=0;
    int findleast=0;
    #define min(a, b) __vamos_min(a, b)
    #define max(a, b) __vamos_max(a, b)
    #define EVBUFSIZE (@BUFSIZE*8)

    typedef enum EVKIND { EVNONE, EVREAD, EVWRITE, EVREADSIZED, EVWRITESIZED, EVLOCK, EVUNLOCK, EVFORK, EVJOIN, EVSKIPSTART, EVSKIPEND, EVDONE } evkind;
    typedef struct {
        uint64_t timestamp;
        int tid;
        int skipend;
        evkind kind;
        union
        {
            struct {
                intptr_t addr;
            } read;
            struct {
                intptr_t addr;
            } write;
            struct {
                intptr_t addr;
                size_t size;
            } read_sized;
            struct {
                intptr_t addr;
                size_t size;
            } write_sized;
            struct {
                intptr_t addr;
            } lock;
            struct {
                intptr_t addr;
            } unlock;
            struct {
                int tid;
            } fork;
            struct {
                int tid;
            } join;
            struct {
            } skipstart;
            struct {
            } skipend;
            struct {
            } done;
        } data;
    } GEvent;
    typedef struct ThrdList_ {
        int tid;
        int skipping;
        struct ThrdList_ * next;
    } ThrdList;

    GEvent evbuf[EVBUFSIZE];
    uint64_t evbufsize = EVBUFSIZE;
    uint64_t evbufstart = 0;
    uint64_t evbufend = EVBUFSIZE;
    uint64_t evbufpos = 0;
    uint64_t nextevbufstart=EVBUFSIZE;
    uint64_t maxts=0;
    int64_t evbuffree=EVBUFSIZE;
    int64_t skipcount=0;
    uint64_t handledcount=0;
    ThrdList * doneThreads=0;
    void evbuf_process(int quick)
    {
        GEvent* ev=evbuf+evbufpos;
        GEvent* evend=evbuf+evbufsize;
        while(ev<evend)
        {
            if(ev->timestamp>0)
            {
                int tid=ev->tid;
                uint64_t ts=ev->timestamp;
                if(ev->skipend)
                {
                    $yield skipend(tid, ts);
                }
                switch(ev->kind)
                {
                    case EVNONE:
                    {
                        printf("Warning: invalid event in buffer with timestamp");
                    }
                    break;
                    case EVREAD:
                    {
                        intptr_t addr = ev->data.read.addr;
                        $yield read(tid, ts, addr);
                    }
                    break;
                    case EVWRITE:
                    {
                        intptr_t addr = ev->data.write.addr;
                        $yield write(tid, ts, addr);
                    }
                    break;
                    case EVREADSIZED:
                    {
                        intptr_t addr = ev->data.read.addr;
                        size_t size=ev->data.read_sized.size;
                        $yield read_sized(tid, ts, addr, size);
                    }
                    break;
                    case EVWRITESIZED:
                    {
                        intptr_t addr = ev->data.write.addr;
                        size_t size=ev->data.write_sized.size;
                        $yield write_sized(tid, ts, addr, size);
                    }
                    break;
                    case EVLOCK:
                    {
                        intptr_t addr = ev->data.lock.addr;
                        $yield lock(tid, ts, addr);
                    }
                    break;
                    case EVUNLOCK:
                    {
                        intptr_t addr = ev->data.unlock.addr;
                        $yield unlock(tid, ts, addr);
                    }
                    break;
                    case EVFORK:
                    {
                        int otid = ev->data.fork.tid;
                        $yield fork(tid, ts, otid);
                    }
                    break;
                    case EVJOIN:
                    {
                        int otid = ev->data.join.tid;
                        $yield join(tid, ts, otid);
                    }
                    break;
                    case EVSKIPSTART:
                    {
                        $yield skipstart(tid, ts);
                    }
                    break;
                    case EVSKIPEND:
                    {
                        $yield skipend(tid, ts);
                    }
                    break;
                    case EVDONE:
                    {
                        $yield done_(tid, ts);
                    }
                    break;
                }
                ev->timestamp=0;
            }
            else if(!quick)
            {
                break;
            }
            evbufpos++;
            ev++;
        }
        if(ev==evend)
        {
            evbufpos=0;
            evbufstart=nextevbufstart;
            evbufend=evbufstart+evbufsize;
            nextevbufstart=evbufend;
            evbuffree=evbufsize;
            ThrdList * lastThread;
            while(doneThreads!=0)
            {
                lastThread=doneThreads;
                doneThreads=doneThreads->next;
                int tid=lastThread->tid;
                $yield done_(tid, evbufstart);
                free(lastThread);
            }
        }
    }

    int evbuf_request(uint64_t ts, GEvent ** out_evaddr, evkind kind, int tid, int *T_skipping)
    { 
        ts=ts-1;
        uint64_t pos=ts%evbufsize;
        nextts=evbufstart+evbufpos+1;
        if(ts>=evbufstart)
        {
            maxts=max(maxts,ts+1);
            if(ts<evbufend)
            {
                *out_evaddr=evbuf+pos;
                (*out_evaddr)->skipend=0;
                (*out_evaddr)->tid=tid;
                (*out_evaddr)->kind=kind;
                (*out_evaddr)->timestamp=ts+1;
                (*out_evaddr)->skipend=*T_skipping;
                *T_skipping=0;
                nonecycles=0;
                nonebarrier=1;
                evbuffree-=1;
                if(pos==evbufpos)
                {
                    return 2;
                }
                else
                {
                    return 1;
                }
            }
            else
            {
                if(ts-evbufend>evbufsize)
                {
                    uint64_t proto_start=ts-(ts%evbufsize);
                    if(proto_start>nextevbufstart)
                    {
                        nextevbufstart=proto_start;
                    }
                }
                if(ts<nextevbufstart)
                {
                    skipcount++;
                    dropcount++;
                    return 0;
                }
                return 3;
            }
        }
        else
        {
            if(!*T_skipping)
            {
                $yield skipstart(tid, nextts);
                *T_skipping=1;
            }
            skipcount++;
            dropcount++;
            return 0;
        }
    }
$$

loopdebug
$$
    printf("evbufstart = %lu\n", evbufstart);
    printf("evbufend = %lu\n", evbufend);
    printf("evbufpos = %lu\n", evbufpos);
    printf("evbuffree = %li\n", evbuffree);
    printf("skipcount = %li\n", skipcount);
    printf("dropcount = %lu\n", dropcount);
    printf("threadcount = %d\n", BG_Threads.size);
    printf("handledcount = %lu\n", handledcount);
    printf("nonecycles = %lu\n", nonecycles);
    printf("nonebarrier = %lu\n", nonebarrier);
    printf("maxts = %lu\n", maxts);
$$

cleanup
$$
    ThrdList * lastThread;
    fprintf(stderr, "Handled %lu events\n", handledcount);
    fprintf(stderr, "Dropped %lu events in %lu holes\n", dropcount, holescount);
    fprintf(stderr, "Found %lu races\n", GetRaceCount());
$$

arbiter : GlobalEvent
{
    choose T from Threads where $$ ($T.curts;<evbufend && ($T.nonets; < evbufstart+evbufpos+1)) || BG_Threads.size==1 $$
    {
        on T : | read(ts,addr)
        $$
            #ifdef DEBUGPRINT
            printf("read! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVREAD, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.read.addr=addr;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | write(ts,addr)
        $$
            #ifdef DEBUGPRINT
            printf("write! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVWRITE, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.write.addr=addr;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | read_n(ts,addr, size)
        $$
            #ifdef DEBUGPRINT
            printf("read_n! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVREADSIZED, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.read_sized.addr=addr;
                ev->data.read_sized.size=size;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | write_n(ts,addr,size)
        $$
            #ifdef DEBUGPRINT
            printf("write_n! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVWRITESIZED, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.write_sized.addr=addr;
                ev->data.write_sized.size=size;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$

        on T : | lock(ts,addr)
        $$
            #ifdef DEBUGPRINT
            printf("lock! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVLOCK, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.lock.addr=addr;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | unlock(ts,addr)
        $$
            #ifdef DEBUGPRINT
            printf("unlock! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVUNLOCK, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.unlock.addr=addr;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | fork(ts,tid)
        $$
            #ifdef DEBUGPRINT
            printf("fork! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVFORK, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.fork.tid=tid;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | join(ts,tid)
        $$
            #ifdef DEBUGPRINT
            printf("join! %lu/%lu/%i\n",ts,evbufend,$T.threadid;);
            #endif
            $T.curts;=ts;
            $T.nonecount;=0;
            GEvent *ev=0;
            int req=evbuf_request(ts, &ev, EVJOIN, $T.threadid;, &$T.skipping;);
            if(ev!=0)
            {
                ev->data.join.tid=tid;
            }
            if(req<3)
            {
                if(req>=2)
                {
                    evbuf_process(0);
                }
                $drop 1 from T;
            }
        $$
        on T : | my_hole(n, mints, maxts)
        $$
            #ifdef DEBUGPRINT
            printf("\033[36m//[a] my_hole(n=%d, mints=%lu, maxts=%lu, tid=%i)\033[0m\n", n, mints, maxts,$T.threadid;);
            #endif
            if(!$T.inhole;)
            {
                $T.curts;=mints;
                $T.nonecount;=0;
                skipcount+=n;
                dropcount+=n;
                holescount++;
                $T.inhole;=1;
                if(!$T.skipping;)
                {
                    GEvent *ev=0;
                    int req=evbuf_request(mints, &ev, EVSKIPSTART, $T.threadid;, &$T.skipping;);
                    if(req<3)
                    {
                        if(req>=2)
                        {
                            evbuf_process(0);
                        }
                        $T.skipping;=1;
                    }
                }
            }
            if($T.inhole;)
            {
                $T.curts;=maxts;
                $T.nonecount;=0;
                GEvent *ev=0;
                int req=evbuf_request(maxts, &ev, EVSKIPEND, $T.threadid;, &$T.skipping;);
                if(ev!=0)
                {
                    ev->skipend=0;//no doubling
                }
                if(req<3)
                {
                    if(req>=2)
                    {
                        evbuf_process(0);
                    }
                    $T.inhole;=0;
                    $drop 1 from T;
                }
            }
        $$
        on T : done
        $$
            #ifdef DEBUGPRINT
            printf("done! %lu/%i\n",evbufend,$T.threadid;);
            #endif
            ThrdList * tl = (ThrdList*) malloc(sizeof(ThrdList));
            tl->tid=$T.threadid;;
            tl->skipping=$T.skipping;;
            tl->next=doneThreads;
            doneThreads=tl;
            if(BG_Threads.size==1)
            {
                evbuf_process(1);
            }
            $remove T from Threads;
        $$
        on T : nothing
        $$
            $T.nonets;=evbufstart+evbufpos+1;
        $$
    }
    choose T from Threads where $$ $T.curts;<evbufend && $T.nonets;>0 $$
    {
        on T : 1
        $$
            $T.nonets;=0;
        $$
    }

    always
    $$
        #ifdef DEBUGPRINT
        printf("%lu > %lu | %lu/%lu | %li / %li\n", maxts, evbufstart, nonecycles, nonebarrier, evbuffree, skipcount);
        #endif
        if(maxts>evbufstart)
        {
            nonecycles++;
            nonebarrier++;
            if(nonecycles>100000&&skipcount>0&&evbuffree-skipcount<=0)
            {
                skipcount-=evbuffree;
                evbuf_process(1);
            }
        }
        else
        {
            nonebarrier++;
        }
    $$
}

monitor {
    on read(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("read(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
        #endif
        monitor_handle_read(tid, timestamp, addr);
        handledcount++;
    $$
    on read_sized(tid, timestamp, addr, size) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("read_sized(tid=%lu, ts=%lu, addr=%p, size=%lu)\n", tid, timestamp, addr, size);
        #endif
        monitor_handle_read_many(tid, timestamp, addr, size);
        handledcount++;
    $$

    on write(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("write(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
        #endif
        monitor_handle_write(tid, timestamp, addr);
        handledcount++;
    $$
    on write_sized(tid, timestamp, addr, size) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("write_sized(tid=%lu, ts=%lu, addr=%li, size=%lu)\n", tid, timestamp, addr,size);
        #endif
        monitor_handle_write_many(tid, timestamp, addr, size);
        handledcount++;
    $$

    on lock(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("lock(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
        #endif
        monitor_handle_lock(tid, timestamp, addr);
        handledcount++;
    $$

    on unlock(tid, timestamp, addr) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("unlock(tid=%lu, ts=%lu, addr=%p)\n", tid, timestamp, addr);
        #endif
        monitor_handle_unlock(tid, timestamp, addr);
        handledcount++;
    $$
    on fork(tid, timestamp, newthreadid) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("fork(tid=%lu, ts=%lu, newtid=%lu\n", tid, timestamp, newthreadid);
        #endif
        monitor_handle_fork(tid, timestamp, newthreadid);
        handledcount++;
    $$
    on join(tid, timestamp, threadid) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("join(tid=%lu, ts=%lu, jointid=%lu\n", tid, timestamp, threadid);
        #endif
        monitor_handle_join(tid, timestamp, threadid);
        handledcount++;
    $$
    on skipstart(tid, timestamp) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("skipstart(tid=%lu, ts=%lu)\n", tid, timestamp);
        #endif
        monitor_handle_skip_start(tid, timestamp);
        handledcount++;
    $$
    on skipend(tid, timestamp) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("skipend(tid=%lu, ts=%lu)\n", tid, timestamp);
        #endif
        monitor_handle_skip_end(tid, timestamp);
        handledcount++;
    $$
    on done_(tid, timestamp) where $$ true $$
    $$
        #ifdef DEBUGPRINT
        printf("DONE\n");
        #endif
        monitor_handle_done(tid, timestamp);
    $$

}
